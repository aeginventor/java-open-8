<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>동시성 안전 구매 API 실험</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 900px;
            margin: 24px auto;
            padding: 0 16px 48px;
            background: #f7f7f9;
        }
        h1, h2, h3 {
            margin-bottom: 8px;
        }
        section {
            background: #ffffff;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }
        label {
            display: block;
            margin: 4px 0;
        }
        input[type="number"] {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            margin-right: 8px;
            width: 120px;
        }
        button {
            padding: 6px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }
        button.primary {
            background: #4b8cf5;
            color: white;
        }
        button.secondary {
            background: #e0e0e0;
        }
        .radio-group {
            display: flex;
            gap: 16px;
            margin: 8px 0;
        }
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .result-box {
            background: #f3f5ff;
            border-radius: 8px;
            padding: 8px 10px;
            margin-top: 8px;
            font-family: "JetBrains Mono", "SF Mono", monospace;
            font-size: 13px;
            white-space: pre-wrap;
        }
        .hint {
            margin-top: 6px;
            font-size: 13px;
            color: #555;
        }
        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 999px;
            font-size: 11px;
            margin-left: 4px;
        }
        .badge.lock {
            background: #e3f2fd;
            color: #1565c0;
        }
        .badge.pessimistic {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .badge.nolock {
            background: #ffebee;
            color: #c62828;
        }
    </style>
</head>
<body>
<h1>동시성 안전 구매 API 실험 UI</h1>
<p style="font-size:14px;color:#555;">
    1) 재고를 설정하고<br>
    2) 현재 재고를 조회하고<br>
    3) 동시 주문 실험을 수행하면서<br>
    4) <strong>no-lock / 로컬 락 / 비관적 락</strong>의 차이를 직접 확인할 수 있습니다.
</p>

<section>
    <h2>1. 재고 설정</h2>
    <label>
        초기 재고:
        <input type="number" id="stockInput" value="100" min="0">
        <button class="primary" onclick="resetStock()">재고 설정</button>
    </label>
    <div id="stockResetResult" class="hint"></div>
</section>

<section>
    <h2>2. 현재 재고 조회</h2>
    <button class="secondary" onclick="fetchCurrentStock()">재고 조회</button>
    <div id="currentStockDisplay" class="result-box" style="display:none;"></div>
</section>

<section>
    <h2>3. 동시 주문 실험</h2>

    <label>
        동시 요청 수 (threads):
        <input type="number" id="threadsInput" value="200" min="1">
    </label>

    <h3>4. 락 방식 선택</h3>
    <div class="radio-group">
        <label>
            <input type="radio" name="method" value="no-lock" checked>
            no-lock <span class="badge nolock">락 없음</span>
        </label>
        <label>
            <input type="radio" name="method" value="lock">
            lock <span class="badge lock">JVM 로컬 락 (@Synchronized)</span>
        </label>
        <label>
            <input type="radio" name="method" value="pessimistic">
            pessimistic <span class="badge pessimistic">DB 비관적 락</span>
        </label>
    </div>

    <button class="primary" onclick="runExperiment()">동시 주문 실험 실행</button>

    <div id="experimentResult" class="result-box" style="display:none;"></div>
    <div id="experimentHint" class="hint"></div>
</section>

<section>
    <h2>4. 로컬 락 vs 비관적 락 개념 실험</h2>
    <p style="font-size:13px;color:#555;">
        이 실험은 실제 DB 대신, 메모리에 있는 재고 값을 가지고<br>
        <strong>인스턴스별 로컬 락(@Synchronized)</strong>과<br>
        <strong>공유 락(전역 락 = 비관적 락 개념)</strong>의 차이를 보여줍니다.
        <br>초기 재고를 1개로 두고, 두 개의 "서버 인스턴스"가 동시에 1개씩 주문한다고 가정합니다.
    </p>
    <button class="secondary" onclick="runLockConceptDemo()">개념 실험 실행</button>
    <div id="lockConceptResult" class="result-box" style="display:none;"></div>
    <div id="lockConceptHint" class="hint"></div>
</section>

<script>
    async function resetStock() {
        const stockVal = parseInt(document.getElementById('stockInput').value, 10);
        if (isNaN(stockVal) || stockVal < 0) {
            alert('0 이상의 숫자를 입력해주세요.');
            return;
        }
        try {
            const resp = await fetch('/ui/reset-stock', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({stock: stockVal})
            });
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                throw new Error(err.detail || '재고 초기화에 실패했습니다.');
            }
            const data = await resp.json();
            document.getElementById('stockResetResult').textContent =
                `상품 ID=${data.productId}의 재고를 ${data.stock}개로 설정했습니다.`;
            document.getElementById('currentStockDisplay').style.display = 'none';
        } catch (e) {
            alert(e.message);
        }
    }

    async function fetchCurrentStock() {
        try {
            const resp = await fetch('/ui/current-stock');
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                throw new Error(err.detail || '재고 조회에 실패했습니다.');
            }
            const data = await resp.json();
            const box = document.getElementById('currentStockDisplay');
            box.style.display = 'block';
            box.textContent = `상품 ID=${data.productId}\n현재 재고: ${data.stock}개`;
        } catch (e) {
            alert(e.message);
        }
    }

    async function runExperiment() {
        const threadsVal = parseInt(document.getElementById('threadsInput').value, 10);
        const method = document.querySelector('input[name="method"]:checked').value;

        if (isNaN(threadsVal) || threadsVal <= 0) {
            alert('동시 요청 수는 1 이상이어야 합니다.');
            return;
        }

        try {
            const resp = await fetch('/ui/run-experiment', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    threads: threadsVal,
                    method: method
                })
            });
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                throw new Error(err.detail || '실험 실행에 실패했습니다.');
            }
            const data = await resp.json();
            const box = document.getElementById('experimentResult');
            box.style.display = 'block';
            box.textContent =
                `락 방식                    : ${data.method}\n` +
                `실험 시작 시 재고           : ${data.initialStock}개\n` +
                `동시 요청 수                : ${data.threads}개\n` +
                `성공 응답 건수              : ${data.successCount}건\n` +
                `실패한 요청 수              : ${data.failureCount}건\n` +
                `실험 이후 남은 재고         : ${data.remainingStock}개\n` +
                `기대한 재고 감소량(응답 기준) : ${data.expectedDecrease}개\n` +
                `실제 재고 감소량(재고 기준)   : ${data.actualDecrease}개\n` +
                `재고 미반영 성공 응답 존재   : ${data.hasGhostSuccess ? '예' : '아니오'}`;

            const hintBox = document.getElementById('experimentHint');
            let hint = '';
            if (method === 'no-lock') {
                if (data.hasGhostSuccess) {
                    hint = 'no-lock에서는 일부 요청에 대해 성공 응답을 보내놓고, 실제 재고에서는 그만큼 줄지 않는 상황이 발생할 수 있습니다.';
                } else {
                    hint = '이번 실험에서는 우연히 응답과 재고가 일치했지만, no-lock 상태에서는 언제든 불일치가 생길 수 있습니다.';
                }
            } else if (method === 'lock') {
                hint = 'lock(@Synchronized)은 한 JVM 인스턴스 안에서만 유효한 로컬 락입니다. 단일 서버에서는 응답과 재고가 잘 맞지만, 서버를 여러 대 띄우는 환경에서는 한계가 있습니다.';
            } else if (method === 'pessimistic') {
                hint = 'pessimistic 락은 DB 레벨에서 행(row)에 락을 걸기 때문에, 여러 서버가 동시에 같은 상품을 갱신해도 응답과 실제 재고가 어긋날 가능성을 줄여줍니다.';
            }
            hintBox.textContent = hint;

            fetchCurrentStock();
        } catch (e) {
            alert(e.message);
        }
    }

     async function runLockConceptDemo() {
        try {
            const resp = await fetch('/ui/lock-concept-demo');
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                throw new Error(err.detail || '개념 실험 실행에 실패했습니다.');
            }
            const data = await resp.json();
            const box = document.getElementById('lockConceptResult');
            box.style.display = 'block';
            box.textContent =
                `초기 재고                    : ${data.initialStock}개\n` +
                `\n` +
                `[로컬 락 (@Synchronized, 인스턴스 기준)]\n` +
                `성공 응답 건수               : ${data.localLockSuccessCount}건\n` +
                `실험 이후 재고               : ${data.localLockFinalStock}개\n` +
                `\n` +
                `[공유 락 (전역 락 = 비관적 락 개념)]\n` +
                `성공 응답 건수               : ${data.globalLockSuccessCount}건\n` +
                `실험 이후 재고               : ${data.globalLockFinalStock}개`;

            const hintBox = document.getElementById('lockConceptHint');
            hintBox.textContent =
                '로컬 락(@Synchronized)은 인스턴스마다 락이 따로라서, 서버 인스턴스를 둘로 나누면 동시에 들어갈 수 있습니다.\n' +
                '그 결과, 어떤 경우에는 두 번 모두 "성공"했다고 응답하면서도 실제 재고는 그만큼 줄지 않는 문제가 생길 수 있습니다.\n' +
                '반대로 공유 락(비관적 락처럼 공통 자원에 거는 락)은 여러 인스턴스가 있어도 한 번에 하나만 들어갈 수 있어,\n' +
                '성공 응답 건수와 실제 재고 감소량이 일치하도록 만듭니다.';
        } catch (e) {
            alert(e.message);
        }
    }
</script>
</body>
</html>
