# 동시성 안전 구매 API
> Kotlin + Spring Boot 기반 재고 감소 API 구현

## 1. 프로젝트 개요

본 프로젝트는 **주문/구매 과정에서 발생하는 동시성 문제**를 직접 재현하고,  
이를 **Kotlin + Spring Boot** 기반의 재고 관리 API와 실험용 웹 UI로 탐구하는 것을 목표로 합니다.

실제 서비스에서는 다음과 같은 문제가 자주 발생합니다.

- 한정 수량 상품에 여러 사용자가 동시에 요청을 보낼 때
- 재고가 음수가 되거나, **재고보다 많이 판 것처럼 보이는 상태**가 발생하는 문제
- 동시성 버그가 로그나 모니터링 없이 조용히 쌓였다가 장애로 이어지는 문제

이 프로젝트에서는 다음을 경험합니다.

- 단순한 재고 차감 로직으로 **동시성 이슈를 직접 재현**해 보고
- 서로 다른 동시성 제어 전략을 적용해 **응답과 실제 재고가 어떻게 달라지는지** 확인합니다.
- 이 과정에서 **Kotlin 문법**, **Spring Boot 구조**, **테스트 코드**를 함께 익힙니다.

---

## 2. 구현 상세

### 2.1 동시성 시나리오

- 하나의 `Product` 엔티티가 있고, `stock` 필드로 재고를 관리합니다.
- 여러 스레드(또는 여러 HTTP 요청)가 동시에 "재고 감소" 요청을 보냅니다.
- 이 때, 구현 방식에 따라 다음과 같은 현상이 발생하거나 방지됩니다.
  - 같은 재고를 두 번 이상 차감
  - 성공 응답을 두 번 보내 놓고 실제 재고는 한 번만 줄어드는 상황
  - 재고가 0 이하(음수)로 떨어지는 상황

### 2.2 동시성 제어 전략

현재는 **세 가지 전략**을 구현했습니다.

1. **NoLockOrderService (락 없음, baseline)**
  - 아무런 동기화 없이 단순히 재고를 조회하고 차감하는 서비스
  - 멀티스레드 환경에서 **응답과 재고가 어긋나는** 문제가 발생할 수 있습니다.
  - 목적: **“동시성 버그를 재현하는 용도”**

2. **LockOrderService (`@Synchronized` 기반, 로컬 락)**
  - Kotlin의 `@Synchronized`를 사용해 `order()` 메서드 전체를 직렬화합니다.
  - 한 번에 하나의 스레드만 주문 로직을 수행할 수 있도록 **JVM 내부에서** 동기화합니다.
  - 단일 인스턴스 환경에서는 동시성 문제를 대부분 막을 수 있지만,  
    인스턴스가 여러 대인 환경에서는 각 인스턴스마다 락이 따로 존재한다는 한계가 있습니다.

3. **PessimisticLockOrderService (DB 비관적 락 기반)**
  - JPA의 `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 사용하여  
    **데이터베이스 레벨에서 행(row)에 락을 거는 방식**입니다.
  - 같은 상품 행을 갱신하려는 트랜잭션끼리는 DB에서 순서를 보장합니다.
  - 여러 인스턴스가 같은 DB를 사용해도, **DB 차원에서 동시성을 제어**할 수 있습니다.

> 세 서비스는 모두 `OrderService` 인터페이스를 구현하며,  
> `OrderRequest.method` 값(`"no-lock"`, `"lock"`, `"pessimistic"`)에 따라 어떤 전략을 사용할지 선택할 수 있습니다.

---

## 3. API 명세

### 3.1 주문 생성 API

`POST /orders`

**Request 본문**

```json
{
  "productId": 1,
  "quantity": 1,
  "method": "lock"
}
```

- `productId` (Long, 필수): 주문할 상품 ID
- `quantity` (Int, 최소 1): 주문 수량
- `method` (String, 선택): `"no-lock"`, `"lock"`, `"pessimistic"` 중 하나, 기본값 `"lock"`

**Response (성공 예시)**

```json
{
  "success": true,
  "remainingStock": 97,
  "method": "lock"
}
```

**Response (실패 예시 – 재고 부족)**

```json
{
  "success": false,
  "error": "BAD_REQUEST",
  "detail": "재고 부족"
}
```

- 예외 응답은 `GlobalExceptionHandler`에서 JSON 형태로 공통 처리합니다.

### 3.2 상품 재고 조회 API

`GET /products/{id}`

**Response 예시**

```json
{
  "id": 1,
  "name": "sample-product",
  "stock": 80
}
```

- 동시성 테스트/부하 테스트 이후, 실제 재고 상태를 확인하는 용도로 사용합니다.

### 3.3 실험용 UI API (내부용)

웹 UI에서 사용하는 별도 API들도 제공합니다.

- `POST /ui/reset-stock`
  - Body: `{ "stock": 100 }`
  - 설명: 실험 대상 상품(기본 ID = 1)의 재고를 지정한 값으로 리셋

- `GET /ui/current-stock`
  - 설명: 현재 실험 대상 상품의 재고 조회

- `POST /ui/run-experiment`
  - Body: `{ "threads": 200, "method": "no-lock" }`
  - 설명: 지정한 동시 요청 수(threads)만큼, 선택한 락 전략으로 **각각 1개씩** 주문을 시도하고 결과를 집계하여 반환
  - Response에는 아래 정보가 포함됩니다.
    - `method`: 사용한 락 전략
    - `initialStock`: 실험 시작 시 재고
    - `threads`: 요청 수
    - `successCount`: **성공 응답 건수**
    - `failureCount`: 실패 요청 수
    - `remainingStock`: 실험 이후 재고
    - `expectedDecrease`: 성공 응답 기준으로 기대되는 재고 감소량
    - `actualDecrease`: 실제 재고 감소량 (`initialStock - remainingStock`)
    - `hasGhostSuccess`: “재고에서는 줄지 않았는데 성공 응답만 보낸 요청”이 하나 이상 있었는지 여부

- `GET /ui/lock-concept-demo`
  - 설명: 메모리 상의 재고 값만 가지고  
    **로컬 락(@Synchronized, 인스턴스 기준)** vs **공유 락(전역 락, 비관적 락 개념)**의 차이를 비교하는 데모

---

## 4. 실행 방법

### 4.1 빌드 및 실행

```bash
./gradlew clean build
./gradlew bootRun
```

서버는 기본적으로 `http://localhost:8080` 에서 실행됩니다.

### 4.2 초기 데이터

애플리케이션 실행 시 `data.sql`을 통해 기본 상품이 자동으로 삽입됩니다.

예시:

```sql
INSERT INTO product (id, name, stock) VALUES (1, 'sample-product', 100);
```

이를 위해 `application.properties`에 다음 설정을 추가했습니다.

```properties
spring.jpa.defer-datasource-initialization=true
```

이 설정과 `data.sql` 덕분에, 별도 API를 호출하지 않아도 **ID=1인 상품**에 대해 바로 실험을 진행할 수 있습니다.

---

## 5. 테스트 구성

테스트는 **동시성 위험이 큰 영역**과 **입력/컨트롤러 계층**에 집중해 구성했습니다.

### 5.1 도메인 레벨 동시성 테스트

- `NoLockConcurrentTest`
  - `NoLockOrderService`에서 멀티스레드 주문을 수행해,
    재고가 비정상적으로 변경되거나,  
    **성공 응답 건수와 실제 재고 감소량이 어긋날 수 있음을** 재현합니다.

- `LockConcurrentTest`
  - `LockOrderService` 사용 시,
    “성공 응답 건수에 해당하는 만큼 재고가 줄었는지”를 기준으로 동작을 검증합니다.
  - 동일한 조건에서 no-lock과 비교했을 때,  
    응답과 재고가 더 잘 맞는지 확인할 수 있습니다.

- `PessimisticLockConcurrentTest`
  - `PessimisticLockOrderService` 사용 시도 위와 동일한 기준으로 검증합니다.
  - 구현 관점에서는 `LockOrderService`와 결과가 비슷해 보이지만,  
    **동기화가 JVM 내부가 아니라 DB 레벨에서 이루어진다**는 점이 다릅니다.

### 5.2 DTO 유효성 검증 테스트

- `OrderRequestValidationTest`
  - `productId`가 없을 때 검증 실패
  - `quantity < 1`일 때 검증 실패
  - Bean Validation이 의도대로 동작하는지 확인합니다.

### 5.3 Controller 통합 테스트

- `OrderControllerTest`
  - 정상 주문 요청 → `200 OK` + `success = true`
  - `productId` 누락 → `400 BAD_REQUEST` + `VALIDATION_ERROR`
  - 재고 부족 상황 → `400 BAD_REQUEST` + `BAD_REQUEST` 에러 코드

이를 통해 **도메인 로직, 입력 레벨, API 레벨**에서 각각의 실패 케이스를 다루고 있음을 보장합니다.

### 5.4 락 전략 개념 테스트

별도의 간단한 테스트/데모 코드를 통해,

- 인스턴스별 `@Synchronized` (로컬 락)
- 전역 공유 락 (비관적 락 개념)

이 어떤 차이를 보이는지 확인할 수 있습니다.

예를 들어, 초기 재고를 1로 두고 두 “인스턴스”가 동시에 주문하면:

- 로컬 락: 두 요청 모두 성공 응답을 보내고, 재고는 -1로 끝나는 상황이 발생할 수 있음
- 공유 락: 한 요청만 성공하고, 재고는 0으로 끝남

---

## 6. 동시성 실험 방법 (웹 UI)

서버를 실행한 뒤 브라우저에서 `http://localhost:8080/`에 접속하면,  
**재고 설정 / 재고 조회 / 동시 주문 실험 / 락 개념 데모**를 한 화면에서 수행할 수 있습니다.

### 6.1 동시 주문 실험

1. **재고 설정**
  - 상단에서 초기 재고를 입력하고 **[재고 입력]** 버튼을 눌러 재고를 설정합니다.

2. **재고 조회**
  - **[재고 조회]** 버튼으로 현재 재고를 확인합니다.

3. **동시 주문 실험 설정**
  - 동시 요청 수(threads)를 입력합니다.  
    (실험에서는 각 요청이 **1개씩** 주문한다고 가정합니다.)
  - `no-lock`, `lock(@Synchronized)`, `pessimistic(DB 비관적 락)` 중 하나를 선택합니다.

4. **실험 실행**
  - **[동시 주문 실험 실행]** 버튼을 누르면,
    - 락 방식
    - 실험 시작 시 재고
    - 동시 요청 수
    - **성공 응답 건수**
    - 실패한 요청 수
    - 실험 이후 남은 재고
    - 성공 응답 기준으로 기대되는 재고 감소량
    - 실제 재고 감소량
    - **“재고에 반영되지 않은 성공 응답이 있었는지 여부”**
      를 한 번에 확인할 수 있습니다.

특히 `no-lock` 전략에서는,  
**성공 응답 건수만큼 재고가 줄지 않은 경우**가 나타날 수 있습니다.  
이는 “사용자에게는 두 번 모두 성공이라고 알려줬는데, 실제 재고는 그만큼 줄지 않은” 동시성 문제를 의미합니다.

### 6.2 로컬 락 vs 비관적 락 개념 실험

동일한 화면에서 **[로컬 락 vs 비관적 락 개념 실험]** 버튼을 통해  
`/ui/lock-concept-demo` API를 호출할 수 있습니다.

- 초기 재고를 1개로 두고,
- “서버 인스턴스” 두 개가 동시에 1개씩 주문한다고 가정했을 때

다음과 같이 비교 결과를 보여줍니다.

- **로컬 락 (@Synchronized, 인스턴스 기준)**
  - 성공 응답 건수: 2건
  - 실험 이후 재고: -1개

- **공유 락 (전역 락 = 비관적 락 개념)**
  - 성공 응답 건수: 1건
  - 실험 이후 재고: 0개

이를 통해,

- 로컬 락은 인스턴스마다 락이 따로라서, 인스턴스를 나누면 동시성 문제가 다시 나타날 수 있고,
- 비관적 락처럼 **공유 자원(DB row)**에 락을 거는 방식은  
  여러 인스턴스가 있어도 “한 번에 하나만 들어갈 수 있게 만드는 전략”이라는 점을 직관적으로 확인할 수 있습니다.

---

## 7. 향후 확장 계획

현재는 **단일 인스턴스 환경 + 로컬 락 + DB 비관적 락** 수준에 집중했습니다.

추후 아래와 같은 확장을 고려할 수 있습니다.

- 데이터베이스 비관적 락(Pessimistic Lock) 튜닝  
  (타임아웃, 데드락 대응 등)
- Redis 분산 락(Redisson)을 이용한 **다중 인스턴스 환경** 대응
- JMeter 등을 이용한 더 정교한 부하/성능 테스트
- 메트릭/로그를 통한 모니터링(동시성 실패 패턴 데이터화)

---

## 8. 이 프로젝트에서 배운 점

- 단순한 재고 감소 로직도 동시성 환경에서는 쉽게 깨질 수 있다는 점
- 동시성 문제를 해결할 때, “성공 응답을 몇 번 보냈는지”와  
  “실제로 재고가 얼마나 줄었는지”가 항상 일치해야 한다는 **일관성 규칙**을 세우는 것이 중요하다는 점
- Kotlin의 `@Synchronized`, JPA의 비관적 락, Spring Boot의 테스트 환경, Bean Validation, MockMvc를 한 번에 경험했다는 점
- 단일 인스턴스에서는 로컬 락만으로도 충분해 보일 수 있지만,  
  다중 인스턴스를 고려하면 DB 락/분산 락 등 **공유 자원 기반의 동시성 전략**이 필요하다는 점

자세한 회고는 별도 소감문에 정리하겠습니다.